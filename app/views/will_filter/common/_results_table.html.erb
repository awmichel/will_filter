<div class="row-fluid">
  <div class="span6">
    <p class="page-count">
      <% if results.total_count > 0 %>
        Showing <%= results.offset_value + 1 %> - <%= results.offset_value + results.length %> of <%= results.total_count %>
      <% else %>
        No results found
      <% end %>
    </p>
  </div>
  <div class="span6">
    <%= paginate(results) %>
  </div>
</div>

<table class="table table-striped table-bordered will-filter">
  <thead>
    <tr>
      <%
        carray = [] # stores the order of the columns

        opts[:columns].each_with_index do |column, index|
          cmeta = {}

          # supported notations for columns => [
          #  :id,
          #  [:id, lambda{|obj| obj.id}],
          #  [:id, lambda{|obj| obj.id}, "color: white"],
          #  [:id, lambda{|obj| obj.id}, {:style => "color: white"}],
          #  [:id, {:filterable => true, :value => lambda{|obj| obj.id}}],
          #  [:id, {:filterable => true, :value => lambda{|obj| obj.id}}],
          #  {:key => :id, :filterable => true}
          # ]

          if column.is_a?(Array)
            if column.size < 2
              raise WillFilter::FilterException.new("Array table column definition must have at least two elements")
            end

            cmeta[:key] = column[0]  # first param must always be the column key

            if column[1].is_a?(Hash)  # second param is a hash
              cmeta.merge!(column[1])
            else
              cmeta[:value] = column[1]
              unless column[2].nil?
                if column[2].is_a?(Hash)   # third param can be a set of attributes
                  cmeta.merge!(column[2])
                elsif column[2].is_a?(String)  # third param can be a string, which represents a style
                  cmeta[:style] = column[2]
                else
                  raise WillFilter::FilterException.new("Unsupported table column format #{column[2]}")
                end
              end
            end
          elsif column.is_a?(Hash)
            cmeta = column
            cmeta[:key] ||= "key_#{index}"
          else
            cmeta[:key] = column
          end

          carray << cmeta

          sort_direction        = filter.column_sorted?(cmeta[:key]) ? filter.order_type : "asc"
          sort_direction_click  = filter.column_sorted?(cmeta[:key]) ? (sort_direction == "asc" ? "desc" : "asc") : "asc"

          if cmeta[:sort_key]
            sort_key = cmeta[:sort_key].call(filter)
          else
            sort_key = cmeta[:key]
          end

          if cmeta[:sortable].nil?
            sortable = filter.contains_column?(cmeta[:key])
          else
            sortable = cmeta[:sortable]
          end

          if cmeta[:title].is_a?(Proc)
            column_title = cmeta[:title].call(filter)
          else
            column_title = cmeta[:title] || filter.condition_title_for(cmeta[:key])
            if sortable
              column_title = link_to(column_title, filter.to_params(:wf_order => cmeta[:key], :wf_order_type => sort_direction_click), :title => "sort by #{cmeta[:key]} ascending", :class => "sort_link")
            end
          end

          # column class name
          title_class_name      = cmeta[:title_class] || cmeta[:key].to_s
          title_class_name      << " sortable"                 if sortable
          title_class_name      << " current_sort"             if filter.column_sorted?(sort_key)
          title_class_name      << " #{sort_direction}"
        %>

        <th class="<%= title_class_name %>">
          <% if sortable %>
            <%= column_title %>
            <div class="sort">
              <%= link_to "", filter.to_params(:wf_order => sort_key, :wf_order_type => 'asc'), :title => "sort by #{sort_key} ascending", :class => 'sort-up' %>
              <%= link_to "", filter.to_params(:wf_order => sort_key, :wf_order_type => 'desc'), :title => "sort by #{sort_key} descending", :class => 'sort-down' %>
            </div>
          <% else %>
            <%= column_title %>
          <% end %>
        </th>
      <% end %>
    </tr>
  </thead>

  <tbody>
    <% results.each_with_index do |obj, index| %>
      <tr>
        <% carray.each_with_index do |cmeta, column_index| %>
          <%
            value_style = cmeta[:style] || '' # should be moved to css
            value_class = cmeta[:class] || ''

            if cmeta[:value].nil?
              value = obj.send(cmeta[:key])
            elsif cmeta[:value].is_a?(Proc)
              value = cmeta[:value].call(obj)
            else
              value = cmeta[:value]
            end

            value_style << 'width:30px;' if cmeta[:key] == :checkbox
            value_class << ' current_sort' if filter.column_sorted?(cmeta[:key])

            if cmeta[:filterable]
              filter_value = cmeta[:value].nil? ? value : obj.send(cmeta[:key])
            end
          %>
          <td style='<%=value_style%>' class='<%=value_class%>'>
              <% if cmeta[:filterable] %>
                <div style='float:right;'><%=link_to(image_tag("will_filter/filter.png", :style=>"width:12px;"), results.add_filter_condition(cmeta[:key], :is, filter_value.to_s).to_params, {:title => "Show only #{filter_value}"}) %></div>
              <% end -%>

               <% if cmeta[:key] == :checkbox %>
                  <%= check_box_tag("#{value}[]", obj.id, false, :id => "wf_check_#{index}", :onClick => "wfVerifyTrigger(this)") %>

               <% elsif value.is_a?(Hash) %>
                  <% value.each do |key, value| %>
                    <strong><%=key%>:</strong> <%= value %>;
                  <% end -%>

                <% elsif value.is_a?(Time) %>
                  <%= value.strftime("%m/%d/%Y %l:%M:%S") %>

                <% elsif value.is_a?(Date) %>
                  <%= value.strftime("%m/%d/%Y") %>

               <% else %>

                  <%= value.to_s %>
               <% end -%>
          </td>
        <% end -%>
      </tr>
    <% end -%>
  </tbody>
</table>
